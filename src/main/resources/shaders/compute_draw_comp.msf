#include math
#include random

const uint BRDF_DIFFUSE = 0;
const uint BRDF_SPECULAR = 1;
const uint BRDF_REFRACT = 2;

struct Material
{
	uint brdfType;
	vec3 radiance;
	vec3 albedo;
	float indexOfRefraction;
};

struct Ray
{
	vec3 origin;
	vec3 dir;
	vec3 invDir;
};

struct Sphere
{
	uint objectId;
	vec3 center;
	float radius;
	float area;
	Material material;
};

struct AABB
{
	uint objectId;
	vec3 min;
	vec3 max;
	float area;
	Material material;
};

struct Intersection
{
	uint objectId;
	vec3 pos;
	vec3 normal;
	bool inside;
	Material material;
};

Ray makeRay(vec3 origin, vec3 dir);
Sphere makeSphere(vec3 center, float radius, Material material);
AABB makeAABB(vec3 center, vec3 size, Material material);

layout(local_size_x = 16, local_size_y = 16) in;

const float INFINITY = 1.0 / 0.0;
const float EPSILON = 1e-4;
const float PI = 3.1415926535897932384626433832795;

const Intersection NO_INTERSECTION = Intersection(-1, vec3(0), vec3(0), false, Material(0, vec3(0), vec3(0), 0));

const bool PROGRESSIVE = true;
const int SAMPLES_PER_PIXEL = 100;
const int NUM_BOUNCES = 5;

layout(rgba32f) uniform image2D framebuffer;
uniform vec2 framebufferSize;

uniform vec4 randInit;
uniform float time;
uniform int numPasses;

uniform vec4 cam00;
uniform vec4 cam10;
uniform vec4 cam01;
uniform vec4 cam11;
uniform vec3 camPos;

uint pixelIndex;
uint sampleIndex;

uint nextObjectId = 0;

Sphere spheres[] = Sphere[](
	//makeSphere(vec3(0,0,40), 100, Material(BRDF_DIFFUSE, vec3(0), vec3(1,0,0), 0)),

	makeSphere(vec3(0,-3,3), 2, Material(BRDF_DIFFUSE, vec3(0), vec3(1), 0)),
	makeSphere(vec3(-3,3,0), 2, Material(BRDF_SPECULAR, vec3(0), vec3(1), 0)),
	makeSphere(vec3(3,3,0), 2, Material(BRDF_SPECULAR, vec3(0), vec3(1), 0))
	
	//makeSphere(vec3(0,0,0), 2, Material(BRDF_DIFFUSE, vec3(0), vec3(0.18)))
);

AABB aabbs[] = AABB[](
	// World floor
	makeAABB(vec3(0, -6, 0), vec3(1000, 0.1, 1000), Material(BRDF_DIFFUSE, vec3(0), vec3(1), 0)),

	//makeAABB(vec3(0, 0, 40), vec3(100, 100, 200), Material(BRDF_DIFFUSE, vec3(0), vec3(1), 0))

	// Cornell box
	makeAABB(vec3(0, -5, 0), vec3(10, 0.1, 10), Material(BRDF_DIFFUSE, vec3(0), vec3(1), 0)), // Floor
	makeAABB(vec3(0, 0, -5), vec3(10, 10, 0.1), Material(BRDF_DIFFUSE, vec3(0), vec3(0,0,1), 0)), // Back
	makeAABB(vec3(-5, 0, 0), vec3(0.1, 10, 10), Material(BRDF_DIFFUSE, vec3(0), vec3(1,0,0), 0)), // Left
	makeAABB(vec3(5, 0, 0), vec3(0.1, 10, 10), Material(BRDF_DIFFUSE, vec3(0), vec3(0,1,0), 0)), // Right
	makeAABB(vec3(0, 5, 0), vec3(10, 0.1, 10), Material(BRDF_DIFFUSE, vec3(0), vec3(1), 0)), // Top
	
	makeAABB(vec3(3, -4, 0), vec3(3, 2, 10), Material(BRDF_REFRACT, vec3(0), vec3(1), 1.5)),
	makeAABB(vec3(0, 4.9, 0), vec3(1, 0.1, 1), Material(BRDF_DIFFUSE, vec3(0.2,0.5,2) * 0, vec3(1), 0)) // Light
);

Ray makeRay(vec3 origin, vec3 dir)
{
	return Ray(origin, dir, 1 / dir);
}

Sphere makeSphere(vec3 center, float radius, Material material)
{
	float area = 4 * PI * radius * radius;
	return Sphere(nextObjectId++, center, radius, area, material);
}

AABB makeAABB(vec3 center, vec3 size, Material material)
{
	float area = 2 * (size.y * size.z + size.x * size.z + size.x * size.y);
	return AABB(nextObjectId++, center - size * 0.5, center + size * 0.5, area, material);
}

uvec4 state;

void initRand()
{
	state = 128 + pixelIndex + uvec4(randInit * 0xFFFFFFFFu);
}

uint randInt()
{
	return nextTausLCG(state);
}

uint randInt(uint bound)
{
	uint threshold = -bound % bound;
	while (true)
	{
		uint r = randInt();
		if (r >= threshold)
			return r % bound;
	}
}

float rand()
{
	return ldexp(randInt(), -32);
}

//const bool STRATIFIED_SAMPLING = true;
const int STRATIFIED_GRID_SIZE = int(sqrt(SAMPLES_PER_PIXEL));
/*const int MAX_STRATIFIED_DIMENSIONS = 5;
uniform int stratifiedGridIndices[MAX_STRATIFIED_DIMENSIONS * SAMPLES_PER_PIXEL];
uint stratifiedGridIndexOffset;
int stratifiedGridDimension;

vec2 randomStratifiedOffset()
{
	if (STRATIFIED_SAMPLING && stratifiedGridDimension < MAX_STRATIFIED_DIMENSIONS)
	{
		uint i = (stratifiedGridIndices[stratifiedGridDimension++ * SAMPLES_PER_PIXEL + sampleIndex] + stratifiedGridIndexOffset) % SAMPLES_PER_PIXEL;
		uvec2 gridCoord = uvec2(i % STRATIFIED_GRID_SIZE, i / STRATIFIED_GRID_SIZE);

		return (gridCoord + vec2(rand(), rand())) / STRATIFIED_GRID_SIZE;
	}
	else
	{
		return vec2(rand(), rand());
	}
}

vec2 randomStratifiedOffset()
{
	if (STRATIFIED_SAMPLING && stratifiedGridDimension++ < 1)
	{
		uvec2 gridCoord = uvec2(sampleIndex % STRATIFIED_GRID_SIZE, sampleIndex / STRATIFIED_GRID_SIZE);

		return (gridCoord + vec2(rand(), rand())) / STRATIFIED_GRID_SIZE;
	}
	else
	{
		return vec2(rand(), rand());
	}
}*/

vec2 randomStratifiedOffset()
{
	uvec2 gridCoord = uvec2(sampleIndex % STRATIFIED_GRID_SIZE, sampleIndex / STRATIFIED_GRID_SIZE);

	return (gridCoord + vec2(rand(), rand())) / STRATIFIED_GRID_SIZE;
}

mat3 createNormalCoordSystem(vec3 N)
{
	vec3 Nt;
    if (abs(N.x) > abs(N.y))
        Nt = vec3(N.z, 0, -N.x) / sqrt(dot(N.xz, N.xz));
    else
        Nt = vec3(0, -N.z, N.y) / sqrt(dot(N.yz, N.yz));
    vec3 Nb = cross(N, Nt);
    return transpose(mat3(Nb, N, Nt));
}

vec3 randomSpherePointUniform()
{
	float u = rand() * 2 - 1;
	float theta = 2 * PI * rand();
	return vec3(vec2(cos(theta), sin(theta)) * sqrt(1 - u * u), u);
}

vec3 randomHemispherePointCosineWeighted(vec3 dir)
{
	float u1 = rand();
	float theta = 2 * PI * rand();
	vec2 disk = vec2(sin(theta), cos(theta)) * sqrt(1 - u1);
	vec3 v = vec3(disk.xy, sqrt(u1)).xzy;

	return v * createNormalCoordSystem(dir);
}

/*vec3 randomHemispherePointCosineWeightedStratified(vec3 dir)
{
	vec2 stratRand = randomStratifiedOffset();
	float theta = acos(sqrt(1 - stratRand.x));
	float phi = 2 * PI * stratRand.y;
	vec3 v = vec3(sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi));

	return v * createNormalCoordSystem(dir);
}*/

void intersectSphere(Sphere s, Ray r, inout float maxDist, inout Intersection inter)
{
	vec3 p = r.origin - s.center;
	float b = -dot(p, r.dir);
	float d = b * b - dot(p, p) + s.radius * s.radius;
	if (d <= 0)
		return;

	d = sqrt(d);
	float tNear = b - d;
	float tFar = b + d;

    bool hit = tFar >= 0;
    float tHit = tNear < 0 ? tFar : tNear;
    if (!hit || tHit > maxDist)
    	return;

	vec3 hitPos = r.origin + r.dir * tHit;
	vec3 hitNormal = normalize(hitPos - s.center);
	bool inside = tNear < 0;
	if (inside)
		hitNormal = -hitNormal;

	inter = Intersection(s.objectId, hitPos, hitNormal, inside, s.material);
	maxDist = tHit;
}

void intersectAABB(AABB aabb, Ray r, inout float maxDist, inout Intersection inter)
{
	vec3 t1 = (aabb.min - r.origin) * r.invDir;
	vec3 t2 = (aabb.max - r.origin) * r.invDir;
 	vec3 tMin = min(t1, t2);
 	vec3 tMax = max(t1, t2);
 	float tNear = max(max(tMin.x, tMin.y), tMin.z);
 	float tFar = min(min(tMax.x, tMax.y), tMax.z);

    bool hit = tFar > 0 && tFar > tNear;
    float tHit = tNear < 0 ? tFar : tNear;
    if (!hit || tHit > maxDist)
    	return;

	vec3 hitPos = r.origin + r.dir * tHit;
 	vec3 hitNormal = vec3(0);
	bool inside = tNear < 0;

	// TODO: Optimize
	if (tMin.x > tMin.y && tMin.x > tMin.z)
	{
		hitNormal = vec3(-sign(r.dir.x), 0, 0);
	}
	else if (tMin.y > tMin.x && tMin.y > tMin.z)
	{
		hitNormal = vec3(0, -sign(r.dir.y), 0);
	}
	else
	{
		hitNormal = vec3(0, 0, -sign(r.dir.z));
	}

	inter = Intersection(aabb.objectId, hitPos, hitNormal, inside, aabb.material);
	maxDist = tHit;
}

Intersection intersectScene(Ray ray, float maxDist)
{
	Intersection inter = NO_INTERSECTION;
	for (int i = 0; i < spheres.length(); i++)
		intersectSphere(spheres[i], ray, maxDist, inter);
	for (int i = 0; i < aabbs.length(); i++)
		intersectAABB(aabbs[i], ray, maxDist, inter);

	return inter;
}

Intersection intersectScene(Ray ray)
{
	return intersectScene(ray, INFINITY);
}

vec3 sampleBRDF(Material material, bool goingOut, vec3 normal, vec3 Lo)
{
	switch(material.brdfType)
	{
		default:
		case BRDF_DIFFUSE:
			return randomHemispherePointCosineWeighted(normal);
		case BRDF_SPECULAR:
			return reflect(-Lo, normal);
		case BRDF_REFRACT:
			float ior = goingOut ? material.indexOfRefraction : 1 / material.indexOfRefraction;
			return refract(-Lo, normal, ior);
	}
}

vec3 evaluateBRDF(Material material, vec3 Li, vec3 normal, vec3 Lo)
{
	switch(material.brdfType)
	{
		default:
		case BRDF_DIFFUSE:
			return material.albedo / PI;
		case BRDF_SPECULAR:
			return material.albedo / dot(normal, Li); // Should be specular instead of albedo
		case BRDF_REFRACT:
			return material.albedo; // TODO: Wrong
	}
}

float evaluatePDF(Material material, vec3 Li, vec3 normal, vec3 Lo)
{
	switch(material.brdfType)
	{
		default:
		case BRDF_DIFFUSE:
			return dot(normal, Li) / PI;
		case BRDF_SPECULAR:
			return 1;
		case BRDF_REFRACT:
			return 1;
	}
}

vec3 lightContribution(uint objectId, Material material, Material lightMaterial, vec3 pos, vec3 lightPos, float lightArea, vec3 normal, vec3 lightNormal, vec3 Lo)
{
	vec3 light = vec3(0);

	vec3 lightPosDiff = lightPos - pos;
	float lightDistSquared = dot(lightPosDiff, lightPosDiff);

	{
		vec3 Li = normalize(lightPosDiff);

		float NdotL = max(0, dot(normal, Li));
		float LNdotL = max(0, dot(lightNormal, -Li));
		if (NdotL > 0 && LNdotL > 0)
		{
			Intersection lightInter = intersectScene(makeRay(pos + normal * EPSILON, Li), INFINITY);
			if (lightInter.objectId == objectId)
			{
				vec3 brdf = evaluateBRDF(material, Li, normal, Lo);

				float lightPdf = 1 / (LNdotL * lightArea / lightDistSquared);
				float brdfPdf = evaluatePDF(material, Li, normal, Lo);
				float weight = balanceHeuristic(1, lightPdf, 1, brdfPdf);

				light += brdf * NdotL * lightMaterial.radiance * weight / lightPdf;
			}
		}
	}

	{
		vec3 Li = sampleBRDF(material, false, normal, Lo);
		vec3 brdf = evaluateBRDF(material, Li, normal, Lo);
		float brdfPdf = evaluatePDF(material, Li, normal, Lo);

		float NdotL = max(0, dot(normal, Li));
		if (brdfPdf > 0 && NdotL > 0)
		{
			float LNdotL = max(0, dot(lightNormal, -Li));
			float lightPdf = 1 / (LNdotL * lightArea / lightDistSquared);
			if (lightPdf > 0)
			{
				Intersection lightInter = intersectScene(makeRay(pos + normal * EPSILON, Li), INFINITY);
				if (lightInter.objectId == objectId)
				{
					float weight = balanceHeuristic(1, brdfPdf, 1, lightPdf);
					light += brdf * NdotL * lightMaterial.radiance * weight / brdfPdf;
				}
			}
		}
	}

	return light;
}

vec3 directIllumination(Material material, vec3 pos, vec3 normal, vec3 Lo)
{
	vec3 light = vec3(0);

	for (int i = 0; i < spheres.length(); i++)
	{
		Sphere sphere = spheres[i];
		if (any(greaterThan(sphere.material.radiance, vec3(0))))
		{
			vec3 lightNormal = randomSpherePointUniform();
			vec3 lightPos = sphere.center + lightNormal * sphere.radius;
			light += lightContribution(sphere.objectId, material, sphere.material, pos, lightPos, sphere.area, normal, lightNormal, Lo);
		}
	}
	for (int i = 0; i < aabbs.length(); i++)
	{
		AABB aabb = aabbs[i];
		if (any(greaterThan(aabb.material.radiance, vec3(0))))
		{
			vec3 lightPos = vec3(0);
			vec3 lightNormal = vec3(0);

			uint side = randInt(6);
			switch (side)
			{
				case 0: // Bottom
					lightPos = vec3(mix(aabb.min.xz, aabb.max.xz, rand()), aabb.min.y).xzy;
					lightNormal = vec3(0, -1, 0);
					break;
				case 1: // Top
					lightPos = vec3(mix(aabb.min.xz, aabb.max.xz, rand()), aabb.max.y).xzy;
					lightNormal = vec3(0, 1, 0);
					break;
				case 2: // Left
					lightPos = vec3(mix(aabb.min.yz, aabb.max.yz, rand()), aabb.min.x).zxy;
					lightNormal = vec3(-1, 0, 0);
					break;
				case 3: // Right
					lightPos = vec3(mix(aabb.min.yz, aabb.max.yz, rand()), aabb.max.x).zxy;
					lightNormal = vec3(1, 0, 0);
					break;
				case 4: // Back
					lightPos = vec3(mix(aabb.min.xy, aabb.max.xy, rand()), aabb.min.z).xyz;
					lightNormal = vec3(0, 0, -1);
					break;
				case 5: // Front
					lightPos = vec3(mix(aabb.min.xy, aabb.max.xy, rand()), aabb.max.z).xyz;
					lightNormal = vec3(0, 0, 1);
					break;
			}

			light += lightContribution(aabb.objectId, material, aabb.material, pos, lightPos, aabb.area, normal, lightNormal, Lo);
		}
	}

	return light;
}

vec3 background(vec3 dir)
{
	//return vec3(0);
	return mix(vec3(0,0,0), vec3(0.2,0.4,1) * 10, pow(dot(dir, vec3(0,1,0)) * 0.5 + 0.5, 5));
}

vec3 calculateColor(Ray startRay)
{
	vec3 color = vec3(0);
	vec3 throughput = vec3(1);
	
	Ray ray = startRay;
	bool specularBounce = false;
	for (int bounces = 0; bounces <= NUM_BOUNCES; bounces++)
	{
		Intersection inter = intersectScene(ray, INFINITY);

		if (inter.objectId == -1) // No intersection -> Background
		{
			color += throughput * background(ray.dir);
			break;
		}

		if (bounces == 0 || specularBounce)
		{
			color += throughput * inter.material.radiance;
		}

		if (inter.material.brdfType != BRDF_SPECULAR)
		{
			color += throughput * directIllumination(inter.material, inter.pos, inter.normal, -ray.dir);
		}

		if (bounces == NUM_BOUNCES)
			break;

		vec3 Li = sampleBRDF(inter.material, inter.inside, inter.normal, -ray.dir);
		vec3 sidedNormal = inter.normal * sign(dot(inter.normal, Li));
		vec3 brdf = evaluateBRDF(inter.material, Li, sidedNormal, -ray.dir);
		float pdf = evaluatePDF(inter.material, Li, sidedNormal, -ray.dir);
		if (brdf == vec3(0) || pdf == 0)
			break;

		float NdotL = dot(sidedNormal, Li);
		throughput *= brdf * (abs(NdotL) / pdf);

		// Russian Roulette
		float rrProb = max(throughput.r, max(throughput.g, throughput.b));
		if (rrProb <= rand())
			break;
		throughput *= 1 / rrProb; // Re-add lost energy for terminated paths

		ray = makeRay(inter.pos + sidedNormal * EPSILON, Li);
		specularBounce = inter.material.brdfType == BRDF_SPECULAR;
	}
	
	return color;
}

void main()
{
	ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
	if (any(greaterThanEqual(coord, framebufferSize)))
		return;
	
	vec2 framebufferSizeInv = 1 / framebufferSize;
	vec2 uvBase = coord * framebufferSizeInv;
	pixelIndex = gl_GlobalInvocationID.y * uint(framebufferSize.x) + gl_GlobalInvocationID.x;
	initRand();
	//stratifiedGridIndexOffset = uint(rand() * 0xFFFFFFFFu);
	
	vec3 color = vec3(0);
	for(int i = 0; i < SAMPLES_PER_PIXEL; i++)
	{
		sampleIndex = i;
		//stratifiedGridDimension = 0;

		vec2 uv = uvBase + randomStratifiedOffset() * framebufferSizeInv;
		vec3 dir = normalize(mix(mix(cam00.xyz, cam01.xyz, uv.y), mix(cam10.xyz, cam11.xyz, uv.y), uv.x));

		color += calculateColor(makeRay(camPos, dir));
	}
	
	if (PROGRESSIVE && numPasses > 1)
	{
		vec3 prev = imageLoad(framebuffer, coord).rgb;
		vec3 newAvg = mix(prev, color, 1.0 / (SAMPLES_PER_PIXEL * numPasses));
		imageStore(framebuffer, coord, vec4(newAvg, 1));
 	}
 	else
 	{
	 	color *= 1.0 / SAMPLES_PER_PIXEL;
	 	imageStore(framebuffer, coord, vec4(color, 1));
 	}
 	
 	//imageStore(framebuffer, coord, vec4(vec3(vec2(gl_LocalInvocationID.xy) / vec2(gl_WorkGroupSize.xy), 1), 1));
	//imageStore(framebuffer, coord, vec4(vec3(vec2(gl_GlobalInvocationID.xy) / vec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy), 1), 1));
	//imageStore(framebuffer, coord, vec4(vec3(rand(),rand(),rand()), 1));
	//imageStore(framebuffer, coord, vec4(vec3(uvBase, 0), 1));
}
