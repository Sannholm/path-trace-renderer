struct Material
{
	vec3 albedo;
	float roughness;
};

struct Ray
{
	vec3 origin;
	vec3 dir;
	vec3 invDir;
};

struct Sphere
{
	vec3 center;
	float radius;
	Material material;
};

struct AABB
{
	vec3 min;
	vec3 max;
	Material material;
};

struct Intersection
{
	bool hit;
	vec3 pos;
	vec3 normal;
	Material material;
};

Ray makeRay(vec3 origin, vec3 dir);
AABB makeAABB(vec3 center, vec3 size, Material material);

layout(local_size_x = 8, local_size_y = 8) in;

const float EPSILON = 0.0001;
const int SAMPLES_PER_PIXEL = 100;
const int NUM_BOUNCES = 5;

layout(rgba8) uniform image2D framebuffer;
uniform vec2 framebufferSize;

uniform float time;

uniform vec3 camPos;
uniform mat4 invViewProjMatrix;

Sphere spheres[] = Sphere[](
	Sphere(vec3(0,-3,0), 2, Material(vec3(0,0,1), 0.5))
);

AABB aabbs[] = AABB[](
	makeAABB(vec3(0, -5, 0), vec3(10, 0.1, 10), Material(vec3(1), 1)),
	makeAABB(vec3(0, 0, -5), vec3(10, 10, 0.1), Material(vec3(1), 1)),
	makeAABB(vec3(-5, 0, 0), vec3(0.1, 10, 10), Material(vec3(1,0,0), 1)),
	makeAABB(vec3(5, 0, 0), vec3(0.1, 10, 10), Material(vec3(0,1,0), 1)),
	makeAABB(vec3(0, 5, 0), vec3(10, 0.1, 10), Material(vec3(1), 1))
);

Ray makeRay(vec3 origin, vec3 dir)
{
	dir = normalize(dir);
	return Ray(origin, dir, 1 / dir);
}

AABB makeAABB(vec3 center, vec3 size, Material material)
{
	return AABB(center - size / 2, center + size / 2, material);
}

uint seed = uint(time);

uint wang_hash()
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}

float rand(float n)
{
	return float(wang_hash()) * (1 / 4294967296.0);
	//return fract(sin(seed) * 43758.5453123);
}

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

vec3 randomSpherePoint(float seed)
{
	float s = rand(seed) * 3.1415926 * 2.0;
	float t = rand(seed) * 2.0 - 1.0;
	return vec3(vec2(sin(s), cos(s)) * sqrt(1.0 - t * t), t);
}

vec3 randomHemispherePoint(vec3 dir, float seed)
{
	vec3 v = randomSpherePoint(seed);
	return v * sign(dot(v, dir));
}

Intersection intersectSphere(Sphere s, Ray r)
{
	vec3 rc = r.origin - s.center;
	float c = dot(rc, rc) - s.radius * s.radius;
	float b = dot(r.dir, rc);
	float d = b * b - c;
	float t = -b - sqrt(abs(d));
	
    bool hit = d >= 0 && t >= 0;
    vec3 hitPos = vec3(0);
    vec3 hitNormal = vec3(0);
    
    if (hit)
    {
    	hitPos = r.origin + r.dir * t;
    	hitNormal = normalize(hitPos - s.center);
	}
	
	return Intersection(hit, hitPos, hitNormal, s.material);
}

Intersection intersectAABB(AABB aabb, Ray r)
{
	vec3 t1 = (aabb.min - r.origin) * r.invDir;
	vec3 t2 = (aabb.max - r.origin) * r.invDir;
 	vec3 tMin = min(t1, t2);
    float tmin = max(max(tMin.x, tMin.y), tMin.z);
    float tmax = min(min(max(t1.x, t2.x), max(t1.y, t2.y)), max(t1.z, t2.z));
	
    bool hit = tmax > max(0, tmin);
    vec3 hitPos = vec3(0);
    vec3 hitNormal = vec3(0);
    
    if (hit)
    {
    	hitPos = r.origin + r.dir * tmin;
    	
    	if (tMin.x > tMin.y && tMin.x > tMin.z)
        {
            hitNormal = vec3(-sign(r.dir.x), 0, 0);
        }
        else if (tMin.y > tMin.x && tMin.y > tMin.z)
        {
            hitNormal = vec3(0, -sign(r.dir.y), 0);
        }
        else
        {
            hitNormal = vec3(0, 0, -sign(r.dir.z));
        }
	}
	
	return Intersection(hit, hitPos, hitNormal, aabb.material);
}

Intersection closestHit(Ray ray, Intersection prev, Intersection new)
{
	if (new.hit)
	{
		if (!prev.hit)
			return new;
		
		vec3 diffNew = new.pos - ray.origin;
		vec3 diffPrev = prev.pos - ray.origin;
		if (dot(diffNew, diffNew) < dot(diffPrev, diffPrev))
		{
			return new;
		}
	}
	
	return prev;
}

Intersection intersectScene(Ray ray)
{
	Intersection inter = Intersection(false, vec3(0), vec3(0), Material(vec3(0), 0));
	for (int i = 0; i < spheres.length(); i++)
		inter = closestHit(ray, inter, intersectSphere(spheres[i], ray));
	for (int i = 0; i < aabbs.length(); i++)
		inter = closestHit(ray, inter, intersectAABB(aabbs[i], ray));
	
	return inter;
}

vec3 calcLighting(vec3 pos, vec3 normal)
{
	const vec3 SUN_DIR = vec3(1,1,1);
	
	vec3 dcol = vec3(0);
	
	Intersection shadowInter = intersectScene(makeRay(pos + normal * EPSILON, SUN_DIR));
	dcol += shadowInter.hit ? 0 : 1;
	
	return dcol;
}

vec3 calcBRDFRay(vec3 pos, vec3 normal, vec3 dir)
{
	return randomHemispherePoint(normal, time);
}

vec3 calculateColor(Ray startRay, int bounces)
{
	vec3 tcol = vec3(0);
	vec3 fcol = vec3(1);
	
	Ray ray = startRay;
	for (int i = 0; i < bounces; i++)
	{
		Intersection inter = intersectScene(ray);
		if (!inter.hit)
		{
			if (i == 0)
				return vec3(0);
			else
				break;
		}
		
		vec3 dcol = calcLighting(inter.pos, inter.normal);
		
		fcol *= inter.material.albedo;
		//if (i == 0)
		tcol += fcol * dcol;
		
		ray = makeRay(inter.pos, calcBRDFRay(inter.pos, inter.normal, ray.dir));
	}
	
	return tcol;
}

void main()
{
	ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
	if (coord.x >= framebufferSize.x || coord.y >= framebufferSize.y)
		return;
	
	vec2 uv = coord / framebufferSize;
	
	vec4 ray00 = vec4(-1, -1, 0, 1) * invViewProjMatrix;
	ray00 /= ray00.w;
	vec4 ray10 = vec4(1, -1, 0, 1) * invViewProjMatrix;
	ray10 /= ray10.w;
	vec4 ray01 = vec4(-1, 1, 0, 1) * invViewProjMatrix;
	ray01 /= ray01.w;
	vec4 ray11 = vec4(1, 1, 0, 1) * invViewProjMatrix;
	ray11 /= ray11.w;
	vec3 dir = mix(mix(ray00.xyz, ray01.xyz, uv.y), mix(ray10.xyz, ray11.xyz, uv.y), uv.x);
	
	vec3 color = vec3(0);
	for(int i = 0; i < SAMPLES_PER_PIXEL; i++)
	{
		color += calculateColor(makeRay(camPos, dir), NUM_BOUNCES);
	}
	color *= 1.0 / SAMPLES_PER_PIXEL;
	
 	imageStore(framebuffer, coord, vec4(color, 1));
 	//imageStore(framebuffer, coord, vec4(vec3(uv, 0), 1));
 	//imageStore(framebuffer, coord, vec4(vec3(vec2(gl_LocalInvocationID.xy) / vec2(gl_WorkGroupSize.xy), 1), 1));
}