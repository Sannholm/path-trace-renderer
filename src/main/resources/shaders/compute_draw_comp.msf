struct Material
{
	vec3 albedo;
	float roughness;
};

struct Ray
{
	vec3 origin;
	vec3 dir;
	vec3 invDir;
};

struct Sphere
{
	vec3 center;
	float radius;
	Material material;
};

struct AABB
{
	vec3 min;
	vec3 max;
	Material material;
};

struct Intersection
{
	bool hit;
	vec3 pos;
	vec3 normal;
	Material material;
};

Ray makeRay(vec3 origin, vec3 dir);
AABB makeAABB(vec3 center, vec3 size, Material material);

layout(local_size_x = 8, local_size_y = 8) in;

layout(rgba8) uniform image2D framebuffer;
uniform vec2 framebufferSize;

uniform float time;

uniform vec3 camPos;
uniform mat4 invViewProjMatrix;

const Sphere spheres[] = Sphere[](
	Sphere(vec3(0,-3,0), 2, Material(vec3(0,0,1), 0.5))
);

const AABB aabbs[] = AABB[](
	makeAABB(vec3(0, -5, 0), vec3(10, 0.1, 10), Material(vec3(1), 1)),
	makeAABB(vec3(0, 0, -5), vec3(10, 10, 0.1), Material(vec3(1), 1)),
	makeAABB(vec3(-5, 0, 0), vec3(0.1, 10, 10), Material(vec3(1,0,0), 1)),
	makeAABB(vec3(5, 0, 0), vec3(0.1, 10, 10), Material(vec3(0,1,0), 1)),
	makeAABB(vec3(0, 5, 0), vec3(10, 0.1, 10), Material(vec3(1), 1))
);

Ray makeRay(vec3 origin, vec3 dir)
{
	return Ray(origin, dir, 1 / dir);
}

AABB makeAABB(vec3 center, vec3 size, Material material)
{
	return AABB(center - size / 2, center + size / 2, material);
}

float rand(float n)
{
	return fract(sin(n) * 43758.5453123);
}

float rand(vec2 co)
{
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 blinkingDot(ivec2 coord)
{
	vec2 d = coord - framebufferSize * 0.5;
	d = d * d;
	const float d2 = sqrt(d.x + d.y) / 300;
	return mix(mix(vec3(1,0,0), vec3(0), sin(time)*0.5+0.5),vec3(0),pow(d2, 2));
}

Intersection intersectSphere(Sphere s, Ray r)
{
	const vec3 rc = r.origin - s.center;
	const float c = dot(rc, rc) - s.radius * s.radius;
	const float b = dot(r.dir, rc);
	const float d = b * b - c;
	const float t = -b - sqrt(abs(d));
	
    const bool hit = d >= 0 && t >= 0;
    vec3 hitPos = vec3(0);
    vec3 hitNormal = vec3(0);
    
    if (hit)
    {
    	hitPos = r.origin + r.dir * t;
    	hitNormal = normalize(hitPos - s.center);
	}
	
	return Intersection(hit, hitPos, hitNormal, s.material);
}

Intersection intersectAABB(AABB aabb, Ray r)
{
	const vec3 t1 = (aabb.min - r.origin) * r.invDir;
	const vec3 t2 = (aabb.max - r.origin) * r.invDir;
 	const vec3 tMin = min(t1, t2);
    const float tmin = max(max(tMin.x, tMin.y), tMin.z);
    const float tmax = min(min(max(t1.x, t2.x), max(t1.y, t2.y)), max(t1.z, t2.z));
	
    const bool hit = tmax > max(0, tmin);
    vec3 hitPos = vec3(0);
    vec3 hitNormal = vec3(0);
    
    if (hit)
    {
    	hitPos = r.origin + r.dir * tmin;
    	
    	if (tMin.x > tMin.y && tMin.x > tMin.z)
        {
            hitNormal = vec3(-sign(r.dir.x), 0, 0);
        }
        else if (tMin.y > tMin.x && tMin.y > tMin.z)
        {
            hitNormal = vec3(0, -sign(r.dir.y), 0);
        }
        else
        {
            hitNormal = vec3(0, 0, -sign(r.dir.z));
        }
	}
	
	return Intersection(hit, hitPos, hitNormal, aabb.material);
}

Intersection closestHit(Ray ray, Intersection prev, Intersection new)
{
	if (new.hit)
	{
		if (!prev.hit)
			return new;
		
		const vec3 diffNew = new.pos - ray.origin;
		const vec3 diffPrev = prev.pos - ray.origin;
		if (dot(diffNew, diffNew) < dot(diffPrev, diffPrev))
		{
			return new;
		}
	}
	
	return prev;
}

Intersection traceScene(Ray ray)
{
	Intersection inter = Intersection(false, vec3(0), vec3(0), Material(vec3(0), 0));
	for (int i = 0; i < spheres.length(); i++)
		inter = closestHit(ray, inter, intersectSphere(spheres[i], ray));
	for (int i = 0; i < aabbs.length(); i++)
		inter = closestHit(ray, inter, intersectAABB(aabbs[i], ray));
	
	return inter;
}

void main()
{
	const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
	if (coord.x >= framebufferSize.x || coord.y >= framebufferSize.y)
		return;
	
	const vec2 uv = coord / framebufferSize;
	
	vec4 ray00 = vec4(-1, -1, 0, 1) * invViewProjMatrix;
	ray00 /= ray00.w;
	vec4 ray10 = vec4(1, -1, 0, 1) * invViewProjMatrix;
	ray10 /= ray10.w;
	vec4 ray01 = vec4(-1, 1, 0, 1) * invViewProjMatrix;
	ray01 /= ray01.w;
	vec4 ray11 = vec4(1, 1, 0, 1) * invViewProjMatrix;
	ray11 /= ray11.w;
	const vec3 dir = normalize(mix(mix(ray00.xyz, ray01.xyz, uv.y), mix(ray10.xyz, ray11.xyz, uv.y), uv.x));
	
	vec3 color = vec3(0);
	
	const int NUM_TRACES = 1;
	for (int i = 0; i < NUM_TRACES; i++)
	{
		Intersection inter = traceScene(makeRay(camPos, dir));
		Intersection inter2 = traceScene(makeRay(inter.pos, reflect(dir, inter.normal)));
		Intersection inter3 = traceScene(makeRay(inter.pos, vec3(1,1,1)));
		
		if (inter.hit)
			color += mix(vec3(0), mix(inter2.material.albedo, inter.material.albedo*max(0.2, dot(vec3(1,1,1), inter.normal)), inter.material.roughness), inter3.hit ? 0.2 : 1);
		//color = vec3(inter.hit ? (length(inter.pos - ray.origin)) : 0);
		//color = vec3(inter.hit ? inter.normal : 0);
		//color = vec3(inter.hit ? (inter.albedo * max(0.2, dot(vec3(1,1,1), inter.normal))) : 0);
	}
	color /= NUM_TRACES;
	
 	imageStore(framebuffer, coord, vec4(color, 1));
 	//imageStore(framebuffer, coord, vec4(vec3(uv, 0), 1));
 	//imageStore(framebuffer, coord, vec4(vec3(vec2(gl_LocalInvocationID.xy) / vec2(gl_WorkGroupSize.xy), 1), 1));
}