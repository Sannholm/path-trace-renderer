struct Material
{
	float radiance;
	vec3 albedo;
	float roughness;
};

struct Ray
{
	vec3 origin;
	vec3 dir;
	vec3 invDir;
};

struct Sphere
{
	vec3 center;
	float radius;
	Material material;
};

struct AABB
{
	vec3 min;
	vec3 max;
	Material material;
};

struct Intersection
{
	bool hit;
	vec3 pos;
	vec3 normal;
	Material material;
};

Ray makeRay(vec3 origin, vec3 dir);
AABB makeAABB(vec3 center, vec3 size, Material material);

layout(local_size_x = 16, local_size_y = 16) in;

const float EPSILON = 0.0001;
const int SAMPLES_PER_PIXEL = 100;
const int NUM_BOUNCES = 5;

const vec3 SUN_DIR = normalize(vec3(1,1,1));

layout(rgba32f) uniform image2D framebuffer;
uniform vec2 framebufferSize;

uniform float randInit;
uniform float time;
uniform int numRuns;

uniform vec3 camPos;
uniform mat4 invViewProjMatrix;

Sphere spheres[] = Sphere[](
	Sphere(vec3(0,-3,3), 2, Material(0, vec3(1), 1)),
	Sphere(vec3(-3,3,0), 2, Material(0, vec3(1), 0)),
	Sphere(vec3(3,3,0), 2, Material(0, vec3(1), 0))
	
	//Sphere(vec3(0,0,0), 2, Material(0, vec3(0.18), 0))
);

AABB aabbs[] = AABB[](
	makeAABB(vec3(0, -5, 0), vec3(10, 0.1, 10), Material(0, vec3(1), 1)), // Floor
	makeAABB(vec3(0, 0, -5), vec3(10, 10, 0.1), Material(0, vec3(1), 1)), // Back
	makeAABB(vec3(-5, 0, 0), vec3(0.1, 10, 10), Material(0, vec3(1,0,0), 1)), // Left
	makeAABB(vec3(5, 0, 0), vec3(0.1, 10, 10), Material(0, vec3(0,1,0), 1)), // Right
	makeAABB(vec3(0, 5, 0), vec3(10, 0.1, 10), Material(0, vec3(1), 1)) // Top
	
	//makeAABB(vec3(0, 0, 0), vec3(0, 0, 0), Material(0, vec3(0), 1))
);

Ray makeRay(vec3 origin, vec3 dir)
{
	return Ray(origin, dir, 1 / dir);
}

AABB makeAABB(vec3 center, vec3 size, Material material)
{
	return AABB(center - size / 2, center + size / 2, material);
}

float seed = randInit;

float rand()
{
	seed += randInit;
	return fract(sin(seed) * 43758.5453123);
}

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

vec3 randomSpherePoint()
{
	float s = rand() * 3.1415926 * 2;
	float t = rand() * 2 - 1;
	return vec3(vec2(sin(s), cos(s)) * sqrt(1 - t * t), t);
}

vec3 randomHemispherePoint(vec3 dir)
{
	vec3 v = randomSpherePoint();
	return v * sign(dot(v, dir));
}

Intersection intersectSphere(Sphere s, Ray r)
{
	vec3 rc = r.origin - s.center;
	float c = dot(rc, rc) - s.radius * s.radius;
	float b = dot(r.dir, rc);
	float d = b * b - c;
	float t = -b - sqrt(abs(d));
	
    bool hit = d >= 0 && t >= 0;
    vec3 hitPos = vec3(0);
    vec3 hitNormal = vec3(0);
    
    if (hit)
    {
    	hitPos = r.origin + r.dir * t;
    	hitNormal = normalize(hitPos - s.center);
	}
	
	return Intersection(hit, hitPos, hitNormal, s.material);
}

Intersection intersectAABB(AABB aabb, Ray r)
{
	vec3 t1 = (aabb.min - r.origin) * r.invDir;
	vec3 t2 = (aabb.max - r.origin) * r.invDir;
 	vec3 tMin = min(t1, t2);
    float tmin = max(max(tMin.x, tMin.y), tMin.z);
    float tmax = min(min(max(t1.x, t2.x), max(t1.y, t2.y)), max(t1.z, t2.z));
	
    bool hit = tmax > max(0, tmin);
    vec3 hitPos = vec3(0);
    vec3 hitNormal = vec3(0);
    
    if (hit)
    {
    	hitPos = r.origin + r.dir * tmin;
    	
    	if (tMin.x > tMin.y && tMin.x > tMin.z)
        {
            hitNormal = vec3(-sign(r.dir.x), 0, 0);
        }
        else if (tMin.y > tMin.x && tMin.y > tMin.z)
        {
            hitNormal = vec3(0, -sign(r.dir.y), 0);
        }
        else
        {
            hitNormal = vec3(0, 0, -sign(r.dir.z));
        }
	}
	
	return Intersection(hit, hitPos, hitNormal, aabb.material);
}

Intersection closestHit(Ray ray, Intersection prev, Intersection new)
{
	if (new.hit)
	{
		if (!prev.hit)
			return new;
		
		vec3 diffNew = new.pos - ray.origin;
		vec3 diffPrev = prev.pos - ray.origin;
		if (dot(diffNew, diffNew) < dot(diffPrev, diffPrev))
		{
			return new;
		}
	}
	
	return prev;
}

Intersection intersectScene(Ray ray)
{
	Intersection inter = Intersection(false, vec3(0), vec3(0), Material(0, vec3(0), 0));
	for (int i = 0; i < spheres.length(); i++)
		inter = closestHit(ray, inter, intersectSphere(spheres[i], ray));
	for (int i = 0; i < aabbs.length(); i++)
		inter = closestHit(ray, inter, intersectAABB(aabbs[i], ray));
	
	return inter;
}

vec3 calcLighting(vec3 pos, vec3 normal, vec3 dir, Material material)
{
	vec3 dcol = vec3(0);
	
	Intersection shadowInter = intersectScene(makeRay(pos + normal * EPSILON, SUN_DIR));
	dcol += vec3(shadowInter.hit ? 0 : max(0, dot(normal, SUN_DIR)));
	
	dcol += material.radiance;
	
	return dcol;
}

vec3 calcBRDFRay(vec3 pos, vec3 normal, vec3 dir, Material material)
{
	if (material.roughness == 1)
		return randomHemispherePoint(normal);
	else
		return reflect(dir, normal);
}

vec3 background(vec3 dir)
{
	return vec3(0);
	return vec3(max(0, dot(dir, vec3(0,-1,0)))) * vec3(0.2,0.2,1) * 10;
}

vec3 calculateColor(Ray startRay)
{
	vec3 tcol = vec3(0);
	vec3 fcol = vec3(1);
	
	Ray ray = startRay;
	for (int i = 0; i < NUM_BOUNCES; i++)
	{
		Intersection inter = intersectScene(ray);
		if (inter.hit)
		{
			vec3 dcol = calcLighting(inter.pos, inter.normal, ray.dir, inter.material);
			
			fcol *= inter.material.albedo;
			//if (i == 0)
			tcol += fcol * dcol * inter.material.roughness;
			
			ray = makeRay(inter.pos, calcBRDFRay(inter.pos, inter.normal, ray.dir, inter.material));
		}
		else
		{
			tcol += fcol * background(ray.dir);
			break;
		}
	}
	
	return tcol;
}

void main()
{
	ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
	if (coord.x >= framebufferSize.x || coord.y >= framebufferSize.y)
		return;
	
	vec4 ray00 = vec4(-1, -1, 0, 1) * invViewProjMatrix;
	ray00 /= ray00.w;
	vec4 ray10 = vec4(1, -1, 0, 1) * invViewProjMatrix;
	ray10 /= ray10.w;
	vec4 ray01 = vec4(-1, 1, 0, 1) * invViewProjMatrix;
	ray01 /= ray01.w;
	vec4 ray11 = vec4(1, 1, 0, 1) * invViewProjMatrix;
	ray11 /= ray11.w;
	
	vec2 framebufferSizeInv = 1 / framebufferSize;
	
	vec3 color = vec3(0);
	for(int i = 0; i < SAMPLES_PER_PIXEL; i++)
	{
		vec2 uv = (coord + vec2(rand(), rand())) * framebufferSizeInv;
		vec3 dir = normalize(mix(mix(ray00.xyz, ray01.xyz, uv.y), mix(ray10.xyz, ray11.xyz, uv.y), uv.x));
	
		color += calculateColor(makeRay(camPos, dir));
	}
	//color *= 1.0 / SAMPLES_PER_PIXEL;
	
	vec3 prev = imageLoad(framebuffer, coord).rgb;
	vec3 newAvg = mix(prev, color, 1.0 / (SAMPLES_PER_PIXEL * numRuns));
	
 	imageStore(framebuffer, coord, vec4(newAvg, 1));
 	//imageStore(framebuffer, coord, vec4(color, 1));
	
	//vec3 color = calculateColor(makeRay(camPos, dir));
 	//imageStore(framebuffer, coord, vec4(imageLoad(framebuffer, coord).rgb + color, 1));
 	
 	//imageStore(framebuffer, coord, vec4(vec3(uv, 0), 1));
 	//imageStore(framebuffer, coord, vec4(vec3(vec2(gl_LocalInvocationID.xy) / vec2(gl_WorkGroupSize.xy), 1), 1));
}