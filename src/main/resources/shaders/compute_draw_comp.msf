layout(local_size_x = 1, local_size_y = 1) in;

layout(rgba8) uniform image2D framebuffer;
uniform vec2 framebufferSize;

uniform float time;

uniform vec3 camPos;
uniform mat4 invViewProjMatrix;

struct Ray
{
	vec3 origin;
	vec3 dir;
};

struct Sphere
{
	vec3 center;
	float radius;
};

struct AABB
{
	vec3 min;
	vec3 max;
};

struct Intersection
{
	bool hit;
	vec3 pos;
	vec3 normal;
};

vec3 blinkingDot(ivec2 coord)
{
	vec2 d = coord - framebufferSize * 0.5;
	d = d * d;
	const float d2 = sqrt(d.x + d.y) / 300;
	return mix(mix(vec3(1,0,0), vec3(0), sin(time)*0.5+0.5),vec3(0),pow(d2, 2));
}

Intersection intersectSphere(Sphere s, Ray r)
{
	const vec3 rc = r.origin - s.center;
	const float c = dot(rc, rc) - s.radius * s.radius;
	const float b = dot(r.dir, rc);
	const float d = b * b - c;
	const float t = -b - sqrt(abs(d));
	
    const bool hit = d >= 0 && t >= 0;
    vec3 hitPos = vec3(0);
    vec3 hitNormal = vec3(0);
    
    if (hit)
    {
    	hitPos = r.origin + r.dir * t;
    	hitNormal = normalize(hitPos - s.center);
	}
	
	return Intersection(hit, hitPos, hitNormal);
}

Intersection intersectAABB(AABB aabb, Ray r)
{
	const vec3 rayDirInv = 1 / r.dir;
	
	const float tx1 = (aabb.min.x - r.origin.x) * rayDirInv.x;
    const float tx2 = (aabb.max.x - r.origin.x) * rayDirInv.x;
 	const float txMin = min(tx1, tx2);
 
    float tmin = txMin;
    float tmax = max(tx1, tx2);
    
    const float ty1 = (aabb.min.y - r.origin.y) * rayDirInv.y;
    const float ty2 = (aabb.max.y - r.origin.y) * rayDirInv.y;
 	const float tyMin = min(ty1, ty2);
 	
 	tmin = max(tmin, tyMin);
    tmax = min(tmax, max(ty1, ty2));
    
    const float tz1 = (aabb.min.z - r.origin.z) * rayDirInv.z;
    const float tz2 = (aabb.max.z - r.origin.z) * rayDirInv.z;
 	const float tzMin = min(tz1, tz2);
 	
 	tmin = max(tmin, tzMin);
    tmax = min(tmax, max(tz1, tz2));
	
    const bool hit = tmax > max(tmin, 0);
    vec3 hitPos = vec3(0);
    vec3 hitNormal = vec3(0);
    
    if (hit)
    {
    	hitPos = r.origin + r.dir * tmin;
    	
    	if (txMin > tyMin && txMin > tzMin)
        {
            hitNormal = vec3(-sign(r.dir.x), 0, 0);
        }
        else if (tyMin > txMin && tyMin > tzMin)
        {
            hitNormal = vec3(0, -sign(r.dir.y), 0);
        }
        else
        {
            hitNormal = vec3(0, 0, -sign(r.dir.z));
        }
	}
	
	return Intersection(hit, hitPos, hitNormal);
}

vec3 traceScene(Ray ray)
{
	const Sphere spheres[] = Sphere[](
		Sphere(vec3(sin(time) * 2, -0.5, -5), 0.5),
		Sphere(vec3(0, 0, -10), 0.5),
		Sphere(vec3(cos(time * 2), sin(time * 2) * 0.75, -10), 0.1),
		Sphere(vec3(2, 0, -10 + cos(time) * 10), 0.5)
	);
	
	const AABB aabbs[] = AABB[](
		AABB(vec3(sin(time) * 2 - 1, -1, -20),
			vec3(sin(time) * 2 + 1, -0.9, -5))
	);
	
	Intersection inter = Intersection(false, vec3(0), vec3(0));
	for (int i = 0; i < spheres.length(); i++)
	{
		Intersection newInter = intersectSphere(spheres[i], ray);
		if (newInter.hit && (!inter.hit || length(newInter.pos - ray.origin) < length(inter.pos - ray.origin)))
		{
			inter = newInter;
		}
	}
	for (int i = 0; i < aabbs.length(); i++)
	{
		Intersection newInter = intersectAABB(aabbs[i], ray);
		if (newInter.hit && (!inter.hit || length(newInter.pos - ray.origin) < length(inter.pos - ray.origin)))
		{
			inter = newInter;
		}
	}
	
	//return vec3(inter.hit ? (length(inter.pos - ray.origin)) : 0);
	//return vec3(inter.hit ? inter.normal : 0);
	return vec3(inter.hit ? mix(vec3(0, 0.2, 0.2), vec3(0.9, 0.9, 0.6), max(0, dot(vec3(1,1,1), inter.normal))) : 0);
}

void main()
{
	const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
	const vec2 uv = coord / framebufferSize;
	
	vec4 ray00 = vec4(-1, -1, 0, 1) * invViewProjMatrix;
	ray00 /= ray00.w;
	vec4 ray10 = vec4(1, -1, 0, 1) * invViewProjMatrix;
	ray10 /= ray10.w;
	vec4 ray01 = vec4(-1, 1, 0, 1) * invViewProjMatrix;
	ray01 /= ray01.w;
	vec4 ray11 = vec4(1, 1, 0, 1) * invViewProjMatrix;
	ray11 /= ray11.w;
	const vec3 dir = normalize(mix(mix(ray00.xyz, ray01.xyz, uv.y), mix(ray10.xyz, ray11.xyz, uv.y), uv.x));
	
	const vec3 color = traceScene(Ray(camPos, dir));
	
 	imageStore(framebuffer, coord, vec4(color, 1));
 	//imageStore(framebuffer, coord, vec4(vec3(uv, 0), 1));
}