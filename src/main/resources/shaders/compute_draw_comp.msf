#include math
#include random

layout(local_size_x = 16, local_size_y = 16) in;

const uint BRDF_DIFFUSE = 0;
const uint BRDF_SPECULAR = 1;
const uint BRDF_REFRACT = 2;
const uint BRDF_DISNEY = 3;

struct Material
{
	uint brdfType;
	vec3 radiance;
	vec3 albedo;
	float indexOfRefraction;
	DisneyParams disneyParams;
};

struct Ray
{
	vec3 origin;
	vec3 dir;
	vec3 invDir;
};

struct Sphere
{
	uint objectId;
	vec3 center;
	float radius;
	float area;
	Material material;
};

struct AABB
{
	uint objectId;
	vec3 min;
	vec3 max;
	float area;
	Material material;
};

struct Disk
{
	uint objectId;
	vec3 center;
	float radius;
	vec3 normal;
	float area;
	Material material;
};

struct Intersection
{
	uint objectId;
	vec3 pos;
	vec3 normal;
	bool inside;
	Material material;
};

Ray makeRay(const vec3 origin, const vec3 dir);
Sphere makeSphere(const vec3 center, const float radius, const Material material);
AABB makeAABB(const vec3 center, const vec3 size, const Material material);
Disk makeDisk(const vec3 center, const float radius, const vec3 normal, const Material material);

const float EPSILON = 1e-4;

const Intersection NO_INTERSECTION = Intersection(-1, vec3(0), vec3(0), false, Material(0, vec3(0), vec3(0), 0, DISNEY_NULL));

const DisneyParams DISNEY_DEF = DisneyParams
(
	vec3(1,1,1), //vec3 baseColor;
	0, //float metallic;
	0, //float subsurface;
	0.5, //float specular;
	1, //float roughness;
	0, //float specularTint;
	0, //float anisotropic;
	0, //float sheen;
	.5, //float sheenTint;
	0, //float clearcoat;
	1 //float clearcoatGloss;
);

const bool PROGRESSIVE = true;
const int SAMPLES_PER_PIXEL = 100;
const int NUM_BOUNCES = 5;

const vec3 SUN_NORMAL = normalize(vec3(0.5, -0.5, -1));

layout(rgba32f) uniform restrict image2D framebuffer;

uniform int numPasses;
uniform vec4 randInit;
uniform float time;

uniform vec4 cam00;
uniform vec4 cam10;
uniform vec4 cam01;
uniform vec4 cam11;
uniform vec3 camPos;

const ivec2 framebufferSize = imageSize(framebuffer);

uint pixelIndex;
uint sampleIndex;

uint nextObjectId = 0;

uvec4 randState;

Sphere spheres[] = Sphere[](
	//makeSphere(vec3(0,0,40), 100, Material(BRDF_DIFFUSE, vec3(0), vec3(1,0,0), 0, DISNEY_DEF)),

	makeSphere(vec3(0,-3,3), 2, Material(BRDF_DISNEY, vec3(0), vec3(1), 0, DISNEY_DEF)),
	makeSphere(vec3(-3,3,0), 2, Material(BRDF_SPECULAR, vec3(0), vec3(1), 0, DISNEY_DEF)),
	makeSphere(vec3(3,3,0), 2, Material(BRDF_SPECULAR, vec3(0), vec3(1), 0, DISNEY_DEF))
	
	//makeSphere(vec3(0,0,0), 2, Material(BRDF_DIFFUSE, vec3(0), vec3(0.18), 0, DISNEY_DEF))
);

AABB aabbs[] = AABB[](
	// World floor
	makeAABB(vec3(0, -6, 0), vec3(1000, 0.1, 1000), Material(BRDF_DISNEY, vec3(0), vec3(1), 0, DISNEY_DEF)),

	//makeAABB(vec3(0, 0, 40), vec3(100, 100, 200), Material(BRDF_DIFFUSE, vec3(0), vec3(1), 0, DISNEY_DEF))

	// Cornell box
	makeAABB(vec3(0, -5, 0), vec3(10, 0.1, 10), Material(BRDF_DISNEY, vec3(0), vec3(1), 0, DISNEY_DEF)), // Floor
	makeAABB(vec3(0, 0, -5), vec3(10, 10, 0.1), Material(BRDF_DISNEY, vec3(0), vec3(0,0,1), 0, DISNEY_DEF)), // Back
	makeAABB(vec3(-5, 0, 0), vec3(0.1, 10, 10), Material(BRDF_DISNEY, vec3(0), vec3(1,0,0), 0, DISNEY_DEF)), // Left
	makeAABB(vec3(5, 0, 0), vec3(0.1, 10, 10), Material(BRDF_DISNEY, vec3(0), vec3(0,1,0), 0, DISNEY_DEF)), // Right
	makeAABB(vec3(0, 5, 0), vec3(10, 0.1, 10), Material(BRDF_DISNEY, vec3(0), vec3(1), 0, DISNEY_DEF)), // Top
	
	makeAABB(vec3(3, -4, 0), vec3(3, 2, 10), Material(BRDF_REFRACT, vec3(0), vec3(1), 1.5, DISNEY_DEF)),
	makeAABB(vec3(0, 4.9, 0), vec3(1, 0.1, 1), Material(BRDF_DISNEY, vec3(0.2,0.5,2) * 0, vec3(1), 0, DISNEY_DEF)) // Light
);

Disk disks[] = Disk[](
	//makeDisk(-SUN_NORMAL * 149600e6, 695700e3, SUN_NORMAL, Material(BRDF_DIFFUSE, vec3(1,1,1) * 100000, vec3(1), 0, DISNEY_DEF)),
	makeDisk(vec3(10,-5,-10), 1, normalize(vec3(1,0,1)), Material(BRDF_DIFFUSE, vec3(10), vec3(1), 0, DISNEY_DEF)),
	makeDisk(vec3(0,2,0), 1, normalize(vec3(0,-1,1)), Material(BRDF_DIFFUSE, vec3(10), vec3(1), 0, DISNEY_DEF))
);

Ray makeRay(const vec3 origin, const vec3 dir)
{
	return Ray(origin, dir, 1 / dir);
}

Sphere makeSphere(const vec3 center, const float radius, const Material material)
{
	float area = 4 * PI * radius * radius;
	return Sphere(nextObjectId++, center, radius, area, material);
}

AABB makeAABB(const vec3 center, const vec3 size, const Material material)
{
	float area = 2 * (size.y * size.z + size.x * size.z + size.x * size.y);
	return AABB(nextObjectId++, center - size * 0.5, center + size * 0.5, area, material);
}

Disk makeDisk(const vec3 center, const float radius, const vec3 normal, const Material material)
{
	float area = PI * radius * radius;
	return Disk(nextObjectId++, center, radius, normal, area, material);
}

void initRand()
{
	randState = 128 + pixelIndex + uvec4(randInit * 0xFFFFFFFFu);
}

uint randInt()
{
	return nextTausLCG(randState);
}

uint randInt(const uint bound)
{
	uint threshold = -bound % bound;
	while (true)
	{
		uint r = randInt();
		if (r >= threshold)
			return r % bound;
	}
}

float rand()
{
	return ldexp(randInt(), -32);
}

//const bool STRATIFIED_SAMPLING = true;
const int STRATIFIED_GRID_SIZE = int(sqrt(SAMPLES_PER_PIXEL));
/*const int MAX_STRATIFIED_DIMENSIONS = 5;
uniform int stratifiedGridIndices[MAX_STRATIFIED_DIMENSIONS * SAMPLES_PER_PIXEL];
uint stratifiedGridIndexOffset;
int stratifiedGridDimension;

vec2 randomStratifiedOffset()
{
	if (STRATIFIED_SAMPLING && stratifiedGridDimension < MAX_STRATIFIED_DIMENSIONS)
	{
		uint i = (stratifiedGridIndices[stratifiedGridDimension++ * SAMPLES_PER_PIXEL + sampleIndex] + stratifiedGridIndexOffset) % SAMPLES_PER_PIXEL;
		uvec2 gridCoord = uvec2(i % STRATIFIED_GRID_SIZE, i / STRATIFIED_GRID_SIZE);

		return (gridCoord + vec2(rand(), rand())) / STRATIFIED_GRID_SIZE;
	}
	else
	{
		return vec2(rand(), rand());
	}
}

vec2 randomStratifiedOffset()
{
	if (STRATIFIED_SAMPLING && stratifiedGridDimension++ < 1)
	{
		uvec2 gridCoord = uvec2(sampleIndex % STRATIFIED_GRID_SIZE, sampleIndex / STRATIFIED_GRID_SIZE);

		return (gridCoord + vec2(rand(), rand())) / STRATIFIED_GRID_SIZE;
	}
	else
	{
		return vec2(rand(), rand());
	}
}*/

vec2 randomStratifiedOffset()
{
	uvec2 gridCoord = uvec2(sampleIndex % STRATIFIED_GRID_SIZE, sampleIndex / STRATIFIED_GRID_SIZE);
	return (gridCoord + vec2(rand(), rand())) / STRATIFIED_GRID_SIZE;
}

/*vec3 randomHemispherePointCosineWeightedStratified(vec3 dir)
{
	vec2 stratRand = randomStratifiedOffset();
	float theta = acos(sqrt(1 - stratRand.x));
	float phi = 2 * PI * stratRand.y;
	vec3 v = vec3(vec2(cos(phi), sin(phi)) * sin(theta), cos(theta));

	return v * vectorCoordSystem(dir);
}*/

bool intersectPlane(const vec3 center, const vec3 normal, const Ray r, out float t)
{
    float denom = dot(-normal, r.dir);
    if (denom > 1e-6)
    {
        t = dot(center - r.origin, -normal) / denom;
        return t >= 0;
    }
    return false;
}

void intersectSphere(const Sphere s, const Ray r, inout float maxDist, inout Intersection inter)
{
	vec3 p = r.origin - s.center;
	float b = -dot(p, r.dir);
	float d = b * b - dot(p, p) + s.radius * s.radius;
	if (d <= 0)
		return;

	d = sqrt(d);
	float tNear = b - d;
	float tFar = b + d;

    bool hit = tFar >= 0;
    float tHit = tNear < 0 ? tFar : tNear;
    if (!hit || tHit > maxDist)
    	return;

	vec3 hitPos = r.origin + r.dir * tHit;
	vec3 hitNormal = normalize(hitPos - s.center);
	bool inside = tNear < 0;
	if (inside)
		hitNormal = -hitNormal;

	inter = Intersection(s.objectId, hitPos, hitNormal, inside, s.material);
	maxDist = tHit;
}

void intersectAABB(const AABB aabb, const Ray r, inout float maxDist, inout Intersection inter)
{
	vec3 t1 = (aabb.min - r.origin) * r.invDir;
	vec3 t2 = (aabb.max - r.origin) * r.invDir;
 	vec3 tMin = min(t1, t2);
 	vec3 tMax = max(t1, t2);
 	float tNear = max(max(tMin.x, tMin.y), tMin.z);
 	float tFar = min(min(tMax.x, tMax.y), tMax.z);

    bool hit = tFar > 0 && tFar > tNear;
    float tHit = tNear < 0 ? tFar : tNear;
    if (!hit || tHit > maxDist)
    	return;

	vec3 hitPos = r.origin + r.dir * tHit;
 	vec3 hitNormal = vec3(0);
	bool inside = tNear < 0;

	if (tMin.x > tMin.y && tMin.x > tMin.z)
	{
		hitNormal = vec3(-sign(r.dir.x), 0, 0);
	}
	else if (tMin.y > tMin.x && tMin.y > tMin.z)
	{
		hitNormal = vec3(0, -sign(r.dir.y), 0);
	}
	else
	{
		hitNormal = vec3(0, 0, -sign(r.dir.z));
	}

	inter = Intersection(aabb.objectId, hitPos, hitNormal, inside, aabb.material);
	maxDist = tHit;
}

void intersectDisk(const Disk d, const Ray r, inout float maxDist, inout Intersection inter)
{
	float t;
	if (!intersectPlane(d.center, d.normal, r, t) || t > maxDist)
		return;

	vec3 hitPos = r.origin + r.dir * t;
	if (sq(hitPos - d.center) > d.radius * d.radius)
		return;

	inter = Intersection(d.objectId, hitPos, d.normal, false, d.material);
	maxDist = t;
}

Intersection intersectScene(const Ray ray, float maxDist)
{
	Intersection inter = NO_INTERSECTION;
	for (int i = 0; i < spheres.length(); i++)
		intersectSphere(spheres[i], ray, maxDist, inter);
	for (int i = 0; i < aabbs.length(); i++)
		intersectAABB(aabbs[i], ray, maxDist, inter);
	for (int i = 0; i < disks.length(); i++)
		intersectDisk(disks[i], ray, maxDist, inter);

	return inter;
}

Intersection intersectScene(const Ray ray)
{
	return intersectScene(ray, INFINITY);
}

vec3 sampleBRDF(const Material material, const bool exiting, const vec3 normal, const vec3 Lo)
{
	switch(material.brdfType)
	{
		default:
		case BRDF_DIFFUSE:
			return sampleHemisphereCosineWeighted(vec2(rand(),rand()), normal);
		case BRDF_SPECULAR:
			return reflect(-Lo, normal);
		case BRDF_REFRACT:
			float ior = exiting ? material.indexOfRefraction : 1 / material.indexOfRefraction;
			return refract(-Lo, normal, ior);
		case BRDF_DISNEY:
			return DisneyBRDFSample(normal, Lo, vec3(rand(),rand(),rand()), material.disneyParams);
	}
}

vec3 evaluateBRDF(const Material material, const vec3 Li, const vec3 normal, const vec3 Lo)
{
	switch(material.brdfType)
	{
		default:
		case BRDF_DIFFUSE:
			return material.albedo / PI;
		case BRDF_SPECULAR:
			return material.albedo / dot(normal, Li); // TODO: Should be specular instead of albedo
		case BRDF_REFRACT:
			return material.albedo; // TODO: Wrong
		case BRDF_DISNEY:

			vec3 tangent = normalToTangent(normal);
			vec3 bitangent = tangentToBitangent(normal, tangent);

			DisneyParams p = material.disneyParams;
			p.baseColor = material.albedo;
			return DisneyBRDF(Li, normal, Lo, tangent, bitangent, p);
	}
}

float evaluatePDF(const Material material, const vec3 Li, const vec3 normal, const vec3 Lo)
{
	switch(material.brdfType)
	{
		default:
		case BRDF_DIFFUSE:
			return dot(normal, Li) / PI;
		case BRDF_SPECULAR:
			return 1;
		case BRDF_REFRACT:
			return 1;
		case BRDF_DISNEY:

			vec3 tangent = normalToTangent(normal);
			vec3 bitangent = tangentToBitangent(normal, tangent);

			return DisneyBRDFPDF(Li, normal, Lo, tangent, bitangent, material.disneyParams);
	}
}

vec3 lightContribution(const uint objectId, const Material material, const vec3 lightRadiance, const vec3 pos, const vec3 lightPos, const float lightArea, const vec3 normal, const vec3 lightNormal, const vec3 Lo)
{
	vec3 light = vec3(0);

	vec3 lightPosDiff = lightPos - pos;
	float lightDistSquared = dot(lightPosDiff, lightPosDiff);

	// MIS: Sampling light
	{
		vec3 Li = normalize(lightPosDiff);

		float NdotL = max(0, dot(normal, Li));
		float LNdotL = max(0, dot(lightNormal, -Li));
		if (NdotL > 0 && LNdotL > 0)
		{
			Intersection lightInter = intersectScene(makeRay(pos + normal * EPSILON, Li), INFINITY);
			if (lightInter.objectId == objectId)
			{
				vec3 brdf = evaluateBRDF(material, Li, normal, Lo);

				float lightPdf = 1 / (LNdotL * lightArea / lightDistSquared);
				float brdfPdf = evaluatePDF(material, Li, normal, Lo);
				float weight = balanceHeuristic(1, lightPdf, 1, brdfPdf);

				light += brdf * NdotL * lightRadiance * weight / lightPdf;
			}
		}
	}

	// MIS: Sampling BRDF
	{
		vec3 Li = sampleBRDF(material, false, normal, Lo);
		vec3 brdf = evaluateBRDF(material, Li, normal, Lo);
		float brdfPdf = evaluatePDF(material, Li, normal, Lo);

		float NdotL = max(0, dot(normal, Li));
		if (brdfPdf > 0 && NdotL > 0)
		{
			float LNdotL = max(0, dot(lightNormal, -Li));
			float lightPdf = 1 / (LNdotL * lightArea / lightDistSquared);
			if (lightPdf > 0)
			{
				Intersection lightInter = intersectScene(makeRay(pos + normal * EPSILON, Li), INFINITY);
				if (lightInter.objectId == objectId)
				{
					float weight = balanceHeuristic(1, brdfPdf, 1, lightPdf);
					light += brdf * NdotL * lightRadiance * weight / brdfPdf;
				}
			}
		}
	}

	return light;
}

vec3 directIllumination(const Material material, const vec3 pos, const vec3 normal, const vec3 Lo)
{
	vec3 light = vec3(0);

	for (int i = 0; i < spheres.length(); i++)
	{
		Sphere sphere = spheres[i];
		if (any(greaterThan(sphere.material.radiance, vec3(0))))
		{
			vec3 lightNormal = sampleSphere(vec2(rand(),rand()));
			vec3 lightPos = sphere.center + lightNormal * sphere.radius;
			light += lightContribution(sphere.objectId, material, sphere.material.radiance, pos, lightPos, sphere.area, normal, lightNormal, Lo);
		}
	}
	for (int i = 0; i < aabbs.length(); i++)
	{
		AABB aabb = aabbs[i];
		if (any(greaterThan(aabb.material.radiance, vec3(0))))
		{
			vec3 lightPos = vec3(0);
			vec3 lightNormal = vec3(0);

			uint side = randInt(6);
			switch (side)
			{
				case 0: // Bottom
					lightPos = vec3(mix(aabb.min.xz, aabb.max.xz, rand()), aabb.min.y).xzy;
					lightNormal = vec3(0, -1, 0);
					break;
				case 1: // Top
					lightPos = vec3(mix(aabb.min.xz, aabb.max.xz, rand()), aabb.max.y).xzy;
					lightNormal = vec3(0, 1, 0);
					break;
				case 2: // Left
					lightPos = vec3(mix(aabb.min.yz, aabb.max.yz, rand()), aabb.min.x).zxy;
					lightNormal = vec3(-1, 0, 0);
					break;
				case 3: // Right
					lightPos = vec3(mix(aabb.min.yz, aabb.max.yz, rand()), aabb.max.x).zxy;
					lightNormal = vec3(1, 0, 0);
					break;
				case 4: // Back
					lightPos = vec3(mix(aabb.min.xy, aabb.max.xy, rand()), aabb.min.z).xyz;
					lightNormal = vec3(0, 0, -1);
					break;
				case 5: // Front
					lightPos = vec3(mix(aabb.min.xy, aabb.max.xy, rand()), aabb.max.z).xyz;
					lightNormal = vec3(0, 0, 1);
					break;
			}

			light += lightContribution(aabb.objectId, material, aabb.material.radiance, pos, lightPos, aabb.area, normal, lightNormal, Lo);
		}
	}
	for (int i = 0; i < disks.length(); i++)
	{
		Disk disk = disks[i];
		if (any(greaterThan(disk.material.radiance, vec3(0))))
		{
			vec3 lightPos = disk.center + sampleDisk(vec2(rand(),rand()), disk.normal) * disk.radius;
			light += lightContribution(disk.objectId, material, disk.material.radiance, pos, lightPos, disk.area, normal, disk.normal, Lo);
		}
	}

	return light;
}

vec3 background(const vec3 dir)
{
	//return vec3(0);
	return mix(vec3(0,0,0), vec3(0.2,0.4,1) * 10, pow(dot(dir, vec3(0,1,0)) * 0.5 + 0.5, 5)) * 0.1;
}

vec3 calculateColor(const Ray startRay)
{
	vec3 color = vec3(0);
	vec3 throughput = vec3(1);
	
	Ray ray = startRay;
	bool specularBounce = false;
	for (int bounces = 0; bounces <= NUM_BOUNCES; bounces++)
	{
		Intersection inter = intersectScene(ray, INFINITY);

		if (inter.objectId == -1) // No intersection -> Background
		{
			color += throughput * background(ray.dir);
			break;
		}

		// Add material radiance
		if (bounces == 0 || specularBounce)
		{
			color += throughput * inter.material.radiance;
		}

		// Add direct lighting
		if (inter.material.brdfType != BRDF_SPECULAR)
		{
			color += throughput * directIllumination(inter.material, inter.pos, inter.normal, -ray.dir);
		}

		if (bounces == NUM_BOUNCES)
			break;

		// Sample BRDF for bounce ray direction and throughput
		vec3 Li = sampleBRDF(inter.material, inter.inside, inter.normal, -ray.dir);
		vec3 sidedNormal = inter.normal * sign(dot(inter.normal, Li));
		vec3 brdf = evaluateBRDF(inter.material, Li, sidedNormal, -ray.dir);
		float pdf = evaluatePDF(inter.material, Li, sidedNormal, -ray.dir);
		if (brdf == vec3(0) || pdf == 0)
			break;

		float NdotL = dot(sidedNormal, Li);
		throughput *= brdf * (abs(NdotL) / pdf);

		// Russian Roulette
		float rrProb = max(throughput.r, max(throughput.g, throughput.b));
		if (rrProb <= rand())
			break;
		throughput *= 1 / rrProb; // Re-add lost energy for terminated paths

		ray = makeRay(inter.pos + sidedNormal * EPSILON, Li);
		specularBounce = inter.material.brdfType == BRDF_SPECULAR;
	}
	
	return color;
}

void main()
{
	ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
	if (any(greaterThanEqual(coord, framebufferSize)))
		return;
	
	vec2 framebufferSizeInv = 1.0 / framebufferSize;
	vec2 uvBase = coord * framebufferSizeInv;
	pixelIndex = gl_GlobalInvocationID.y * framebufferSize.x + gl_GlobalInvocationID.x;
	initRand();
	//stratifiedGridIndexOffset = uint(rand() * 0xFFFFFFFFu);
	
	vec3 color = vec3(0);
	for(int i = 0; i < SAMPLES_PER_PIXEL; i++)
	{
		sampleIndex = i;
		//stratifiedGridDimension = 0;

		vec2 uv = uvBase + randomStratifiedOffset() * framebufferSizeInv;
		vec3 dir = normalize(mix(mix(cam00.xyz, cam01.xyz, uv.y), mix(cam10.xyz, cam11.xyz, uv.y), uv.x));

		color += calculateColor(makeRay(camPos, dir));
	}
	
	if (PROGRESSIVE && numPasses > 1)
	{
		vec3 prev = imageLoad(framebuffer, coord).rgb;
		vec3 newAvg = mix(prev, color, 1.0 / (SAMPLES_PER_PIXEL * numPasses));
		imageStore(framebuffer, coord, vec4(newAvg, 1));
 	}
 	else
 	{
	 	color *= 1.0 / SAMPLES_PER_PIXEL;
	 	imageStore(framebuffer, coord, vec4(color, 1));
 	}
 	
 	//imageStore(framebuffer, coord, vec4(vec3(vec2(gl_LocalInvocationID.xy) / vec2(gl_WorkGroupSize.xy), 1), 1));
	//imageStore(framebuffer, coord, vec4(vec3(vec2(gl_GlobalInvocationID.xy) / vec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy), 1), 1));
	//imageStore(framebuffer, coord, vec4(vec3(rand(),rand(),rand()), 1));
	//imageStore(framebuffer, coord, vec4(vec3(uvBase, 0), 1));
}
