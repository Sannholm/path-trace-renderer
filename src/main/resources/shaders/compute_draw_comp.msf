struct Material
{
	vec3 radiance;
	vec3 albedo;
	float roughness;
};

struct Ray
{
	vec3 origin;
	vec3 dir;
	vec3 invDir;
};

struct Sphere
{
	vec3 center;
	float radius;
	Material material;
};

struct AABB
{
	vec3 min;
	vec3 max;
	Material material;
};

struct Intersection
{
	bool hit;
	vec3 pos;
	vec3 normal;
	Material material;
};

Ray makeRay(vec3 origin, vec3 dir);
AABB makeAABB(vec3 center, vec3 size, Material material);

layout(local_size_x = 16, local_size_y = 16) in;

const float EPSILON = 0.0001;
const float M_PI = 3.1415926535897932384626433832795;

const bool PROGRESSIVE = true;
const int SAMPLES_PER_PIXEL = 100;
const int SUB_PIXEL_GRID_SIZE = int(sqrt(SAMPLES_PER_PIXEL));
const int NUM_BOUNCES = 5;

const vec3 SUN_DIR = normalize(vec3(1,1,1));

layout(rgba32f) uniform image2D framebuffer;
uniform vec2 framebufferSize;

uniform float randInit;
uniform float time;
uniform int numRuns;

uniform vec3 camPos;
uniform mat4 invViewProjMatrix;

Sphere spheres[] = Sphere[](
	Sphere(vec3(0,-3,3), 2, Material(vec3(1), vec3(1), 1)),
	Sphere(vec3(-3,3,0), 2, Material(vec3(0), vec3(1), 0)),
	Sphere(vec3(3,3,0), 2, Material(vec3(0), vec3(1), 0))
	
	//Sphere(vec3(0,0,0), 2, Material(0, vec3(0.18), 0))
);

AABB aabbs[] = AABB[](
	makeAABB(vec3(0, -5, 0), vec3(10, 0.1, 10), Material(vec3(0), vec3(1), 1)), // Floor
	makeAABB(vec3(0, 0, -5), vec3(10, 10, 0.1), Material(vec3(0), vec3(0,0,1), 1)), // Back
	makeAABB(vec3(-5, 0, 0), vec3(0.1, 10, 10), Material(vec3(0), vec3(1,0,0), 1)), // Left
	makeAABB(vec3(5, 0, 0), vec3(0.1, 10, 10), Material(vec3(0), vec3(0,1,0), 1)), // Right
	makeAABB(vec3(0, 5, 0), vec3(10, 0.1, 10), Material(vec3(0), vec3(1), 1)), // Top
	
	makeAABB(vec3(3, -4, 0), vec3(3, 2, 10), Material(vec3(0), vec3(1), 1)),
	makeAABB(vec3(0, 4.9, 0), vec3(1, 0.1, 1), Material(vec3(0.2,0.5,1) * 30, vec3(1), 1)) // Light
	
	//makeAABB(vec3(0, 0, 0), vec3(0, 0, 0), Material(vec3(0), vec3(0), 1))
);

Ray makeRay(vec3 origin, vec3 dir)
{
	return Ray(origin, dir, 1 / dir);
}

AABB makeAABB(vec3 center, vec3 size, Material material)
{
	return AABB(center - size / 2, center + size / 2, material);
}

float seed = gl_GlobalInvocationID.y * gl_WorkGroupSize.x * gl_NumWorkGroups.x + gl_GlobalInvocationID.x;

float rand()
{
	seed += randInit;
	return fract(sin(seed) * 43758.5453123);
}

vec3 randomSpherePoint()
{
	float s = rand() * M_PI * 2;
	float t = rand() * 2 - 1;
	return vec3(vec2(sin(s), cos(s)) * sqrt(1 - t * t), t);
}

vec3 randomHemispherePoint(vec3 dir)
{
	vec3 v = randomSpherePoint();
	return v * sign(dot(v, dir));
}

void createNormalCoordSystem(vec3 N, out vec3 Nt, out vec3 Nb)
{
    if (abs(N.x) > abs(N.y))
        Nt = vec3(N.z, 0, -N.x) / sqrt(N.x * N.x + N.z * N.z);
    else
        Nt = vec3(0, -N.z, N.y) / sqrt(N.y * N.y + N.z * N.z);
    Nb = cross(N, Nt);
}

vec3 randomHemispherePointCosineWeighted(vec3 dir)
{
	float u1 = rand();
	float u2 = rand();
	float theta = 2 * M_PI * u2;
	vec2 disk = vec2(sin(theta), cos(theta)) * sqrt(1 - u1);
	vec3 v = vec3(disk.x, sqrt(u1), disk.y);

	vec3 Nt, Nb;
	createNormalCoordSystem(dir, Nt, Nb);

	return vec3(
		v.x * Nb.x + v.y * dir.x + v.z * Nt.x,
		v.x * Nb.y + v.y * dir.y + v.z * Nt.y,
		v.x * Nb.z + v.y * dir.z + v.z * Nt.z
	);
}

Intersection intersectSphere(Sphere s, Ray r)
{
	vec3 rc = r.origin - s.center;
	float c = dot(rc, rc) - s.radius * s.radius;
	float b = dot(r.dir, rc);
	float d = b * b - c;
	float t = -b - sqrt(abs(d));
	
    bool hit = d >= 0 && t >= 0;
    vec3 hitPos = vec3(0);
    vec3 hitNormal = vec3(0);
    
    if (hit)
    {
    	hitPos = r.origin + r.dir * t;
    	hitNormal = normalize(hitPos - s.center);
	}
	
	return Intersection(hit, hitPos, hitNormal, s.material);
}

Intersection intersectAABB(AABB aabb, Ray r)
{
	vec3 t1 = (aabb.min - r.origin) * r.invDir;
	vec3 t2 = (aabb.max - r.origin) * r.invDir;
 	vec3 tMin = min(t1, t2);
    float tNear = max(max(tMin.x, tMin.y), tMin.z);
    float tFar = min(min(max(t1.x, t2.x), max(t1.y, t2.y)), max(t1.z, t2.z));
	
    bool hit = tFar > max(0, tNear);
    vec3 hitPos = vec3(0);
    vec3 hitNormal = vec3(0);
    
    if (hit)
    {
    	hitPos = r.origin + r.dir * tNear;
    	
    	if (tMin.x > tMin.y && tMin.x > tMin.z)
        {
            hitNormal = vec3(-sign(r.dir.x), 0, 0);
        }
        else if (tMin.y > tMin.x && tMin.y > tMin.z)
        {
            hitNormal = vec3(0, -sign(r.dir.y), 0);
        }
        else
        {
            hitNormal = vec3(0, 0, -sign(r.dir.z));
        }
	}
	
	return Intersection(hit, hitPos, hitNormal, aabb.material);
}

Intersection closestHit(Ray ray, Intersection prev, Intersection new)
{
	if (new.hit)
	{
		if (!prev.hit)
			return new;
		
		vec3 diffNew = new.pos - ray.origin;
		vec3 diffPrev = prev.pos - ray.origin;
		if (dot(diffNew, diffNew) < dot(diffPrev, diffPrev))
		{
			return new;
		}
	}
	
	return prev;
}

Intersection intersectScene(Ray ray)
{
	Intersection inter = Intersection(false, vec3(0), vec3(0), Material(vec3(0), vec3(0), 0));
	for (int i = 0; i < spheres.length(); i++)
		inter = closestHit(ray, inter, intersectSphere(spheres[i], ray));
	for (int i = 0; i < aabbs.length(); i++)
		inter = closestHit(ray, inter, intersectAABB(aabbs[i], ray));
	
	return inter;
}

vec3 sampleBRDFDir(Material material, vec3 dir, vec3 normal)
{
	if (material.roughness == 1)
		return randomHemispherePointCosineWeighted(normal);
	else
		return reflect(-dir, normal);
}

vec3 evaluateBRDF(Material material, vec3 Li, vec3 normal, vec3 Lo)
{
	if (material.roughness == 1)
		return material.albedo / M_PI;
	else
		return material.albedo / dot(normal, Li); // Should be specular instead of albedo
}

float evaluatePDF(Material material, vec3 Li, vec3 normal, vec3 Lo)
{
	if (material.roughness == 1)
		return dot(normal, Li) / M_PI;
	else
		return 1;
}

vec3 background(vec3 dir)
{
	return vec3(0);
	return vec3(max(0, dot(dir, vec3(0,-1,0)))) * vec3(0.2,0.2,1);
}

vec3 calculateColor(Ray startRay)
{
	vec3 color = vec3(0);
	vec3 throughput = vec3(1);
	
	Ray ray = startRay;
	for (int i = 0; i < NUM_BOUNCES + 1; i++)
	{
		Intersection inter = intersectScene(ray);

		if (!inter.hit) // No intersection -> Background
		{
			color += throughput * background(ray.dir);
			break;
		}

		color += throughput * inter.material.radiance;

		//for (int i2 = 0; i2 < LIGHTS.length(); i2++)
		/*{
			vec3 dirToLight = SUN_DIR;
			Intersection shadowInter = intersectScene(makeRay(inter.pos + inter.normal * EPSILON, dirToLight));
			if (!shadowInter.hit)
			{
				vec3 lightBrdf = evaluateBRDF(inter.material, dirToLight, inter.normal, -ray.dir);
				float lightPdf = evaluatePDF(inter.material, dirToLight, inter.normal, -ray.dir);
				color += throughput * lightBrdf * max(0, dot(inter.normal, dirToLight)) / lightPdf;
			}
		}*/

		vec3 brdfDir = sampleBRDFDir(inter.material, -ray.dir, inter.normal);
		vec3 brdf = evaluateBRDF(inter.material, brdfDir, inter.normal, -ray.dir);
		float pdf = evaluatePDF(inter.material, brdfDir, inter.normal, -ray.dir);

		throughput *= max(vec3(0), brdf * dot(inter.normal, brdfDir) / pdf);

		// Russian Roulette
		float rrProb = max(throughput.r, max(throughput.g, throughput.b));
		if (rrProb <= rand())
			break;
		throughput *= 1 / rrProb; // Re-add lost energy for terminated paths

		ray = makeRay(inter.pos + inter.normal * EPSILON, brdfDir);
	}
	
	return color;
}

void main()
{
	ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
	if (coord.x >= framebufferSize.x || coord.y >= framebufferSize.y)
		return;
	
	vec4 ray00 = vec4(-1, -1, 0, 1) * invViewProjMatrix;
	ray00 /= ray00.w;
	vec4 ray10 = vec4(1, -1, 0, 1) * invViewProjMatrix;
	ray10 /= ray10.w;
	vec4 ray01 = vec4(-1, 1, 0, 1) * invViewProjMatrix;
	ray01 /= ray01.w;
	vec4 ray11 = vec4(1, 1, 0, 1) * invViewProjMatrix;
	ray11 /= ray11.w;
	
	vec3 color = vec3(0);
	for(int i = 0; i < SAMPLES_PER_PIXEL; i++)
	{
		ivec2 gridPos = ivec2(i % SUB_PIXEL_GRID_SIZE, i / SUB_PIXEL_GRID_SIZE);
		vec2 subPixelOffset = (gridPos + vec2(rand(), rand())) / SUB_PIXEL_GRID_SIZE;

		vec2 uv = (coord + subPixelOffset) / framebufferSize;
		vec3 dir = normalize(mix(mix(ray00.xyz, ray01.xyz, uv.y), mix(ray10.xyz, ray11.xyz, uv.y), uv.x));
	
		color += calculateColor(makeRay(camPos, dir));
	}
	
	if (PROGRESSIVE)
	{
		vec3 prev = numRuns == 1 ? vec3(0) : imageLoad(framebuffer, coord).rgb;
		vec3 newAvg = mix(prev, color, 1.0 / (SAMPLES_PER_PIXEL * numRuns));
		
	 	imageStore(framebuffer, coord, vec4(newAvg, 1));
 	}
 	else
 	{
	 	color *= 1.0 / SAMPLES_PER_PIXEL;
	 	imageStore(framebuffer, coord, vec4(color, 1));
 	}
 	
 	//imageStore(framebuffer, coord, vec4(vec3(vec2(gl_LocalInvocationID.xy) / vec2(gl_WorkGroupSize.xy), 1), 1));
	//imageStore(framebuffer, coord, vec4(vec3(vec2(gl_GlobalInvocationID.xy) / vec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy), 1), 1));
}
